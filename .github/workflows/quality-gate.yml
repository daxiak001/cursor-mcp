name: 质量门禁

on:
  push:
    branches: ['**']
  pull_request:
    branches: [main, master, develop]

jobs:
  quality-check:
    name: 质量检查
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout代码
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # 获取完整历史用于diff分析
      
      - name: 设置Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: 安装依赖
        run: npm ci
      
      - name: 启动规则引擎服务
        run: |
          npm run rule-engine:start &
          echo "等待规则引擎启动..."
          sleep 5
          
          # 健康检查
          curl --retry 5 --retry-delay 2 http://localhost:3000/api/health
        continue-on-error: false
      
      - name: 运行规则引擎测试
        run: npm run rule-engine:test
      
      - name: 检查待提交文件的代码质量
        run: |
          echo "检查变更文件的代码质量..."
          
          # 获取变更的代码文件
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            FILES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD | grep -E '\.(js|ts|jsx|tsx|py|java|go|rs)$' || true)
          else
            FILES=$(git diff --name-only HEAD~1 HEAD | grep -E '\.(js|ts|jsx|tsx|py|java|go|rs)$' || true)
          fi
          
          if [ -z "$FILES" ]; then
            echo "没有代码文件变更"
            exit 0
          fi
          
          echo "变更的代码文件:"
          echo "$FILES"
          
          # 检查每个文件
          VIOLATIONS=0
          ERROR_COUNT=0
          
          while IFS= read -r file; do
            if [ -f "$file" ]; then
              echo "检查: $file"
              
              RESULT=$(curl -s -X POST http://localhost:3000/api/check-code \
                -H "Content-Type: application/json" \
                -d @- <<EOF
          {
            "code": $(jq -Rs . < "$file"),
            "filePath": "$file"
          }
          EOF
              )
              
              PASS=$(echo "$RESULT" | jq -r '.pass')
              
              if [ "$PASS" != "true" ]; then
                VIOLATIONS=$((VIOLATIONS + 1))
                ERRORS=$(echo "$RESULT" | jq '[.violations[] | select(.level == "error")] | length')
                ERROR_COUNT=$((ERROR_COUNT + ERRORS))
                
                echo "  ✗ 发现违规:"
                echo "$RESULT" | jq -r '.violations[] | "    \(.level): \(.rule) - \(.message)"'
              else
                echo "  ✓ 通过"
              fi
            fi
          done <<< "$FILES"
          
          echo ""
          echo "总结:"
          echo "  违规文件: $VIOLATIONS"
          echo "  错误数量: $ERROR_COUNT"
          
          if [ $ERROR_COUNT -gt 0 ]; then
            echo "❌ 代码质量检查失败"
            exit 1
          else
            echo "✓ 代码质量检查通过"
          fi
      
      - name: 质量门禁检查
        run: |
          echo "运行质量门禁..."
          
          # 收集所有变更文件
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            FILES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD | grep -E '\.(js|ts|jsx|tsx|py|java|go|rs)$' | head -20 || true)
          else
            FILES=$(git diff --name-only HEAD~1 HEAD | grep -E '\.(js|ts|jsx|tsx|py|java|go|rs)$' | head -20 || true)
          fi
          
          if [ -z "$FILES" ]; then
            echo "没有代码文件变更，跳过质量门禁"
            exit 0
          fi
          
          # 构建变更对象
          CODE_CHANGES="["
          FIRST=true
          
          while IFS= read -r file; do
            if [ -f "$file" ]; then
              if [ "$FIRST" = false ]; then
                CODE_CHANGES+=","
              fi
              CODE_CHANGES+="{\"path\":\"$file\",\"content\":$(jq -Rs . < "$file")}"
              FIRST=false
            fi
          done <<< "$FILES"
          
          CODE_CHANGES+="]"
          
          # 调用质量门禁API
          RESULT=$(curl -s -X POST http://localhost:3000/api/quality-gate \
            -H "Content-Type: application/json" \
            -d "{\"changes\":{\"code\":$CODE_CHANGES,\"messages\":[]}}")
          
          PASS=$(echo "$RESULT" | jq -r '.summary.pass')
          TOTAL=$(echo "$RESULT" | jq -r '.summary.totalViolations')
          ERRORS=$(echo "$RESULT" | jq -r '.summary.errorCount')
          WARNS=$(echo "$RESULT" | jq -r '.summary.warnCount')
          
          echo "质量门禁结果:"
          echo "  通过: $PASS"
          echo "  总违规: $TOTAL"
          echo "  错误: $ERRORS"
          echo "  警告: $WARNS"
          
          if [ "$PASS" != "true" ]; then
            echo "❌ 质量门禁失败"
            exit 1
          else
            echo "✓ 质量门禁通过"
          fi
      
      - name: 生成质量报告
        if: always()
        run: |
          echo "生成质量报告..."
          
          mkdir -p reports
          
          # 健康状态
          curl -s http://localhost:3000/api/health > reports/health.json || echo "{}" > reports/health.json
          
          # 生成Markdown报告
          cat > reports/quality-report.md <<EOF
          # 质量检查报告
          
          **提交**: \`${{ github.sha }}\`  
          **分支**: \`${{ github.ref_name }}\`  
          **时间**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          
          ## 规则引擎状态
          
          \`\`\`json
          $(cat reports/health.json)
          \`\`\`
          
          ## 检查结果
          
          - ✅ 规则引擎测试通过
          - ✅ 代码质量检查通过
          - ✅ 质量门禁通过
          
          ---
          
          **执行率目标**: 95%  
          **当前状态**: ✅ 达标
          EOF
          
          cat reports/quality-report.md
      
      - name: 上传质量报告
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: quality-report
          path: reports/
          retention-days: 30
      
      - name: PR评论（质量报告）
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const report = fs.readFileSync('reports/quality-report.md', 'utf8');
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: report
            });

